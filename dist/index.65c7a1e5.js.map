{"mappings":"AAAA,EAAkC,AAAlC,6FAA+F;AAClC,EAAG,AAAhE,0JAA4J;SAEvD,QAApF,CAAC,EAAE,EAAE,IAAI,EAAE,CAAC;IACzB,EAAY,AAAZ,4BAA8B;IACZ,GAAf,CAAC,MAAM,GAAG,IAAI;IACjB,MAAM,CAAC,QAAQ,GAAI,CAAC;QAChB,EAAE,EAAE,MAAM,EAAE,CAAC;YACT,MAAM,GAAG,KAAK;YACd,EAAE,CAAC,KAAK,CAAC,IAAI,EAAE,SAAS;YACxB,UAAU,KAAO,CAAC;gBACd,MAAM,GAAG,IAAI;YACjB,CAAC,EAAE,IAAI;QACX,CAAC;IACL,CAAC;AACL,CAAC;eAEc,GAAG,GAAG,CAAC;IAClB,KAAK,CAAC,EAAE,GAAG,QAAQ,CAAC,OAAO,CAAC,GAAG,EAAE,EAAE;IAEnC,EAAE,CAAC,CAAC,EAAE,CAAC;IACP,KAAK,CAAC,KAAK,CAAC,EAAE;IACd,EAAE,CAAC,CAAC,EAAE,CAAC;IACP,KAAK,CAAC,KAAK,CAAC,EAAE;IACd,EAAE,CAAC,CAAC,EAAE,CAAC;IACP,KAAK,CAAC,KAAK,CAAC,EAAE;IACd,EAAE,CAAC,CAAC,EAAE,CAAC;IACP,KAAK,CAAC,KAAK,CAAC,EAAE;IACd,EAAE,CAAC,CAAC,EAAE,CAAC;IACP,EAAwB,AAAxB,gDAAkD;IAExB,KAArB,CAAC,KAAK,CAAC,EAAE;IACd,EAAE,CAAC,CAAC,EAAE,CAAC;IACP,KAAK,CAAC,KAAK,CAAC,EAAE;IACd,EAAE,CAAC,CAAC,EAAE,CAAC;AACP,EAAU,AAAV,cAAU;AACd,CAAC;AAED,KAAK,CAAC,KAAK,IAAI,EAAE,GAAK,GAAG,CAAC,OAAO,EAAE,OAAO,GAAK,UAAU,CAAC,OAAO,EAAE,EAAE;;;AAErE,GAAG;AAEH,EAgBG,AAhBH,+JAgBG,AAhBH,EAgBG,UACM,SAAS,CAAC,GAAG,EAAE,CAAC;IACrB,KAAK,CAAC,MAAM,GAAG,CAAC;IAAA,CAAC;IACjB,GAAG,CAAE,KAAK,CAAC,GAAG,IAAI,GAAG,CAAE,CAAC;QACpB,KAAK,CAAC,MAAM,GAAG,GAAG,CAAC,KAAK,CAAC,CAAG;QAC5B,EAAE,EAAE,MAAM,CAAC,MAAM,KAAK,CAAC,EACnB,MAAM,CAAC,GAAG,IAAI,GAAG,CAAC,GAAG;aAClB,CAAC;YACJ,KAAK,CAAC,UAAU,GAAG,MAAM;YACzB,GAAG,CAAE,GAAG,CAAC,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,MAAM,CAAC,MAAM,EAAE,CAAC,GAAI,CAAC;gBACrC,KAAK,CAAC,QAAQ,GAAG,MAAM,CAAC,CAAC;gBACzB,EAAE,GAAG,UAAU,CAAC,QAAQ,GACpB,UAAU,CAAC,QAAQ,IAAI,CAAC;gBAAA,CAAC;gBAE7B,EAAE,EAAE,CAAC,KAAK,MAAM,CAAC,MAAM,GAAG,CAAC,EACvB,UAAU,CAAC,QAAQ,IAAI,GAAG,CAAC,GAAG;gBAElC,UAAU,GAAG,UAAU,CAAC,QAAQ;YACpC,CAAC;QACL,CAAC;IACL,CAAC;AACL,CAAC","sources":["src/main.js"],"sourcesContent":["//  函数是一个在日常开发中经常会使用的函数，它的功能是这样子的：\r\n// 经过它包装的函数 fn，在两次调用时间间隔小于 wait 时间的时候，只会在最后一次调用完，再经过 wait 时间后被执行\r\n\r\nfunction debounce(fn, wait) {\r\n    // 在这里写下你的代码\r\n    let canUse = true;\r\n    return function () {\r\n        if (canUse) {\r\n            canUse = false;\r\n            fn.apply(this, arguments);\r\n            setTimeout(() => {\r\n                canUse = true;\r\n            }, wait);\r\n        }\r\n    };\r\n}\r\n\r\nasync function run() {\r\n    const a1 = debounce(console.log, 50);\r\n\r\n    a1(1, 2);\r\n    await sleep(10);\r\n    a1(2, 3);\r\n    await sleep(20);\r\n    a1(3, 4);\r\n    await sleep(30);\r\n    a1(4, 5);\r\n    await sleep(40);\r\n    a1(5, 6);\r\n    // 经过 50 毫秒（近似），只打印出 5 6\r\n\r\n    await sleep(51);\r\n    a1(6, 7);\r\n    await sleep(10);\r\n    a1(7, 8);\r\n    // 打印出 7 8\r\n}\r\n\r\nconst sleep = (ms) => new Promise((resolve) => setTimeout(resolve, ms));\r\n\r\nrun();\r\n\r\n/**\r\n * obj = {\r\n 'a.b.c': 1,\r\n 'a.d': 2,\r\n 'e': 3,\r\n}\r\nfunction transform(obj) {...}\r\n{\r\n  a: {\r\n     b: {\r\n       c: 1\r\n     },\r\n    d: 2\r\n   },\r\n   e: 3\r\n}\r\n */\r\nfunction transform(obj) {\r\n    const newObj = {};\r\n    for (const key in obj) {\r\n        const keyArr = key.slice(\".\");\r\n        if (keyArr.length === 0) {\r\n            newObj[key] = obj[key];\r\n        } else {\r\n            const tempNewObj = newObj;\r\n            for (let i = 0; i < keyArr.length; i++) {\r\n                const arrValue = keyArr[i];\r\n                if (!tempNewObj[arrValue]) {\r\n                    tempNewObj[arrValue] = {};\r\n                }\r\n                if (i === keyArr.length - 1) {\r\n                    tempNewObj[arrValue] = obj[key];\r\n                }\r\n                tempNewObj = tempNewObj[arrValue];\r\n            }\r\n        }\r\n    }\r\n}\r\n"],"names":[],"version":3,"file":"index.65c7a1e5.js.map","sourceRoot":"/__parcel_source_root/"}